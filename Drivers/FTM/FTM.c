/******************** (C) COPYRIGHT 2011 野火嵌入式开发工作室 ********************
 * 文件名       ：FTM.c
 * 描述         ：FTM定时器，目前有 PWM、输入捕捉功能
 *
 * 实验平台     ：野火kinetis开发板
 * 库版本       ：
 * 嵌入系统     ：
 *
 * 作者         ：野火嵌入式开发工作室
 * 淘宝店       ：http://firestm32.taobao.com
 * 技术支持论坛 ：http://www.ourdev.cn/bbs/bbs_list.jsp?bbs_id=1008
**********************************************************************************/

#include "common.h"
#include "gpio.h"      //IO口操作
#include "sysinit.h"
#include "FTM.h"
#include "drivers_cfg.h"


/*********** FTMn_CHn PWM输出初始化函数 ***********/
/*
        --FTM0--  --FTM1--  --FTM2--
CH0       PTC1      PTA8      PTA10
CH1       PTC2      PTA9      PTA11
CH2       PTC3       ×         ×
CH3       PTC4       ×         ×
CH4       PTD4       ×         ×
CH5       PTD5       ×         ×
CH6       PTD6       ×         ×
CH7       PTD7       ×         ×

×表示没有
*/
volatile struct FTM_MemMap *FTMx[3] = {FTM0_BASE_PTR, FTM1_BASE_PTR, FTM2_BASE_PTR}; //定义三个指针数组保存 FTMn 的地址

extern int countR;
extern s16 countL;
/*************************************************************************
*                             野火嵌入式开发工作室
*
*  函数名称：FTM_PWM_init
*  功能说明：初始化FTM的PWM功能并设置频率、占空比。设置通道输出占空比。
*  参数说明：FTMn        模块号（FTM0、  FTM1、  FTM2）
*            CHn         通道号（CH0~CH7）
*            freq        频率（单位为Hz）
*            duty        占空比
*  函数返回：无
*  修改时间：2012-2-14
*  备    注：同一个FTM，各通道的PWM频率是一样的，共3个FTM，即可以输出3个不同频率PWM
*************************************************************************/
void FTM_PWM_init(FTMn ftmn, CHn ch, u32 freq, u32 duty)
{
    u32 clk_hz = (periph_clk_khz * 1000) >> 1;       //bus频率/2
    u16 mod;
    u8 sc_ps;
    u16 cv;

    ASSERT( (ftmn == FTM0) || ( (ftmn == FTM1 || ftmn == FTM2 ) && (ch <= CH1))   ); //检查传递进来的通道是否正确
    ASSERT( freq <= (clk_hz >> 1) );              //用断言检测 频率 是否正常 ,频率必须小于时钟二分之一

    /*       计算频率设置        */
    mod = (clk_hz >> 16 ) / freq ;
    for(sc_ps = 0; (mod >> sc_ps) >= 1; sc_ps++);
    if(freq < 1000)sc_ps++;
    mod = (clk_hz >> sc_ps) / freq;
    cv = (duty * (mod - 0 + 1)) / FTM_PRECISON;

    /******************* 开启时钟 和 复用IO口*******************/
    //注，这里代码虽然长，但编译时会删掉很多没用的部分，不影响速度
    switch(ftmn)
    {
    case FTM0:
        SIM_SCGC6 |= SIM_SCGC6_FTM0_MASK;                           //使能FTM0时钟
        switch(ch)
        {
        case CH0:
            //if(FTM0_CH0 == PTC1)
            //{
                SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
                PORT_PCR_REG(PORTC_BASE_PTR, 1) = PORT_PCR_MUX(4);  // PTC1
          /*  }
            else if(FTM0_CH0 == PTA3)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 3) = PORT_PCR_MUX(3);  // PTA3
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }*/
            break;

        case CH1:
            //if(FTM0_CH1 == PTC2)
            //{
                SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
                PORT_PCR_REG(PORTC_BASE_PTR, 2) = PORT_PCR_MUX(4);  // PTC2
            /*}
            else if(FTM0_CH1 == PTA4)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 4) = PORT_PCR_MUX(3);  // PTA4
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }*/
            break;

        case CH2:
           // if(FTM0_CH2 == PTC3)
           // {
                SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
                PORT_PCR_REG(PORTC_BASE_PTR, 3) = PORT_PCR_MUX(4);  // PTC3
           /* }
            else if(FTM0_CH2 == PTA5)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 5) = PORT_PCR_MUX(3);  // PTA5
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }*/
            break;

        case CH3:
            //if(FTM0_CH3 == PTC4)
            //{
                SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
                PORT_PCR_REG(PORTC_BASE_PTR, 4) = PORT_PCR_MUX(4);  // PTC4
           /* }
            else if(FTM0_CH3 == PTA6)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 6) = PORT_PCR_MUX(3);  // PTA6
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }*/
            break;

        case CH4:
           // if(FTM0_CH4 == PTD4)
           // {
                SIM_SCGC5 |= SIM_SCGC5_PORTD_MASK;
                PORT_PCR_REG(PORTD_BASE_PTR, 4) = PORT_PCR_MUX(4);  // PTD4
            /*}
            else if(FTM0_CH4 == PTA7)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 7) = PORT_PCR_MUX(3);  // PTA7
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }*/
            break;

        case CH5:
            if(FTM0_CH5 == PTD5)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTD_MASK;
                PORT_PCR_REG(PORTD_BASE_PTR, 5) = PORT_PCR_MUX(4);  // PTD5
            }
            else if(FTM0_CH5 == PTA0)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 0) = PORT_PCR_MUX(3);  // PTA0
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH6:
            if(FTM0_CH6 == PTD6)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTD_MASK;
                PORT_PCR_REG(PORTD_BASE_PTR, 6) = PORT_PCR_MUX(4);  // PTD6
            }
            else if(FTM0_CH6 == PTA1)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 1) = PORT_PCR_MUX(3);  // PTA1
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH7:
            /*if(FTM0_CH7 == PTD7)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTD_MASK;
                PORT_PCR_REG(PORTD_BASE_PTR, 7) = PORT_PCR_MUX(4);  // PTD7
            }
            else if(FTM0_CH7 == PTA2)
            {*/
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 2) = PORT_PCR_MUX(3);  // PTA2
           /* }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }*/
            break;
        default:
            return;
        }
        break;

    case FTM1:
        SIM_SCGC6 |= SIM_SCGC6_FTM1_MASK;                           //使能FTM1时钟
        switch(ch)
        {
        case CH0:
            if(FTM1_CH0 == PTA8)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 8) = PORT_PCR_MUX(3);  // PTA8
            }
            else if(FTM1_CH0 == PTA12)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 12) = PORT_PCR_MUX(3);  // PTA12
            }
            else if(FTM1_CH0 == PTB0)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
                PORT_PCR_REG(PORTB_BASE_PTR, 0) = PORT_PCR_MUX(3);  // PTB0
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;


        case CH1:
            if(FTM1_CH1 == PTA9)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 9) = PORT_PCR_MUX(3);  // PTA9
            }
            else if(FTM1_CH1 == PTA13)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 13) = PORT_PCR_MUX(3);  // PTA13
            }
            else if(FTM1_CH1 == PTB1)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
                PORT_PCR_REG(PORTB_BASE_PTR, 1) = PORT_PCR_MUX(3);  // PTB1
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        default:
            return;
        }
        break;
    case FTM2:
        SIM_SCGC3 |= SIM_SCGC3_FTM2_MASK;                           //使能FTM2时钟
        switch(ch)
        {
        case CH0:
            if(FTM2_CH0 == PTA10)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 10) = PORT_PCR_MUX(3);  // PTA10
            }
            else if(FTM2_CH0 == PTB18)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 18) = PORT_PCR_MUX(3);  // PTB18
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH1:
            if(FTM2_CH1 == PTA11)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 11) = PORT_PCR_MUX(3);  // PTA11
            }
            else if(FTM2_CH1 == PTB19)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 19) = PORT_PCR_MUX(3);  // PTB19
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        default:
            return;
        }
        break;
    default:
        break;
    }
    /******************** 选择输出模式为 边沿对齐PWM *******************/
    //通道状态控制，根据模式来选择 边沿或电平
    FTM_CnSC_REG(FTMx[ftmn], ch) &= ~FTM_CnSC_ELSA_MASK;
    FTM_CnSC_REG(FTMx[ftmn], ch) = FTM_CnSC_MSB_MASK | FTM_CnSC_ELSB_MASK;
    //MSnB:MSnA = 1x
    // ELSnB:ELSnA = 10   High-true pulses  (clear Output on match)
    // ELSnB:ELSnA = 11   Low-true pulses   (set Output on match)
    // Edge-aligned PWM  边沿对齐PWM波   《k16 reference manual.pdf》  P944  或者  《K60P144M100SF2RM.pdf》P1001


    /******************** 配置时钟和分频 ********************/
    FTM_SC_REG(FTMx[ftmn])    = FTM_SC_CPWMS_MASK | FTM_SC_PS(sc_ps) | FTM_SC_CLKS(1);  //没有使能溢出中断
    FTM_CNTIN_REG(FTMx[ftmn]) = 0;                                                      // Channel (n) Value  。设置脉冲宽度：(CnV - CNTIN).
    FTM_MOD_REG(FTMx[ftmn])   = mod;                                                    //Modulo value模数, EPWM的周期为 ：MOD - CNTIN + 0x0001
    FTM_CNTIN_REG(FTMx[ftmn]) = 0;                                                      //Counter Initial Value 计数器初始化值
    FTM_CnV_REG(FTMx[ftmn], ch) = cv;
    FTM_CNT_REG(FTMx[ftmn])   = 0;                                                      //计数器。只有低16位可用

}




/*************************************************************************
*                             野火嵌入式开发工作室
*
*  函数名称：FTM_PWM_Duty
*  功能说明：设置通道占空比
*  参数说明：FTMn        模块号（FTM0、  FTM1、  FTM2）
*            CHn         通道号（CH0~CH7）
*            duty        占空比
*  函数返回：无
*  修改时间：2012-2-14
*  备    注：
*************************************************************************/
void FTM_PWM_Duty(FTMn ftmn, CHn ch, u32 duty)
{
    u32 cv;
    u32 mod;

    ASSERT( (ftmn == FTM0) || ( (ftmn == FTM1 || ftmn == FTM2 ) && (ch <= CH1)) ); //检查传递进来的通道是否正确
    ASSERT(duty <= FTM_PRECISON);     //用断言检测 占空比是否合理

    //占空比 = (CnV-CNTIN)/(MOD-CNTIN+1)
    mod = FTM_MOD_REG(FTMx[ftmn]);        //读取 MOD 的值

    cv = (duty * (mod - 0 + 1)) / FTM_PRECISON;

    // 配置FTM通道值
    FTM_CnV_REG(FTMx[ftmn], ch) = cv;

}

/*************************************************************************
*
*  函数名称：PWM_SET
*  功能说明：设置占空比
*  函数返回：无
*  修改时间：2015-4-10
*  备    注：
*************************************************************************/



void PWM_SET(int pwm_left,int pwm_right) 
{
	pwm_left+=5;
	pwm_right+=5;
    
//    if (countR>=450)
//    {
//       if (pwm_left>0) pwm_left+=2;
//       else pwm_left-=1;
//    }
//    
//    if (countR>=400)
//    {
//       if (pwm_left>0) pwm_left+=1;
//       else pwm_left-=1;
//    }
    
    
//    if (countL<=300)
//    {
//       if (pwm_right>0) pwm_right+=8;
//       else pwm_right-=8;
//    }
//     if (countL<=450)
//     {
//       if (pwm_right>0) pwm_right+=4;
//       else pwm_right-=4;
//     }
    
    pwm_right-=4;
    
    if(pwm_left>  430)
		pwm_left=  430;
	if(pwm_left< -430)
		pwm_left= -430;
	if(pwm_right> 430)
		pwm_right= 430;
	if(pwm_right<-430)
		pwm_right=-430;
    

//    if (countR>300)
//    {
//        if (pwm_left>0) pwm_left-=2;
//       else pwm_left+=2;
//    }


	if(pwm_left<0)
	FTM_PWM_Duty(FTM0 , CH0,430+pwm_left);
	else
	FTM_PWM_Duty(FTM0 , CH0,570+pwm_left);
    
	if(pwm_right<0)
	FTM_PWM_Duty(FTM0 , CH1,430+pwm_right);
	else
	FTM_PWM_Duty(FTM0 , CH1,570+pwm_right);	
}


/*************************************************************************
*                             野火嵌入式开发工作室
*
*  函数名称：FTM_PWM_freq
*  功能说明：设置FTM的频率
*  参数说明：FTMn        模块号（FTM0、  FTM1、  FTM2）
*            freq        频率（单位为Hz）
*  函数返回：无
*  修改时间：2012-2-14
*  备    注：同一个FTM，各通道的PWM频率是一样的，共3个FTM，即可以输出3个不同频率PWM
*************************************************************************/
void FTM_PWM_freq(FTMn ftmn, u32 freq)             //设置FTM的频率
{
    u32 clk_hz = (periph_clk_khz * 1000) >> 1;        //bus频率/2
    u32 mod;
    u8 sc_ps;


    ASSERT( freq <= (clk_hz >> 1) );              //用断言检测 频率 是否正常 ,频率必须小于时钟二分之一

    /*       计算频率设置        */
    mod = (clk_hz >> 16 ) / freq ;
    for(sc_ps = 0; (mod >> sc_ps) >= 1; sc_ps++);
    mod = (clk_hz >> sc_ps) / freq;


    /******************** 配置时钟和分频 ********************/
    FTM_SC_REG(FTMx[ftmn])    = FTM_SC_CPWMS_MASK | FTM_SC_PS(sc_ps) | FTM_SC_CLKS(1);  //没有使能溢出中断
    FTM_CNTIN_REG(FTMx[ftmn]) = 0;                                                      // Channel (n) Value  。设置脉冲宽度：(CnV - CNTIN).
    FTM_MOD_REG(FTMx[ftmn])   = mod;                                                    //Modulo value模数, EPWM的周期为 ：MOD - CNTIN + 0x0001
    FTM_CNTIN_REG(FTMx[ftmn]) = 0;                                                      //Counter Initial Value 计数器初始化值
    FTM_CNT_REG(FTMx[ftmn])   = 0;                                                      //计数器。只有低16位可用
}




//////////////////////////////// 以上为输出PWM  //////////////////////////////////////////

//////////////////////////////// 以下为输入捕捉 //////////////////////////////////////////

/*************************************************************************
*                             野火嵌入式开发工作室
*
*  函数名称：FTM_Input_init
*  功能说明：输入捕捉初始化函数
*  参数说明：FTMn        模块号（FTM0、  FTM1、  FTM2）
*            CHn         通道号（CH0~CH7）
*            Input_cfg   输入捕捉配置（Rising、Falling、Rising_or_Falling）上升沿捕捉、下降沿捕捉、跳变沿捕捉
*  函数返回：无
*  修改时间：2012-1-26
*  备    注：CH0~CH3可以使用过滤器，未添加这功能
*************************************************************************/
void FTM_Input_init(FTMn ftmn, CHn ch, Input_cfg cfg)
{
    ASSERT( (ftmn == FTM0) || ( (ftmn == FTM1 || ftmn == FTM2 ) && (ch <= CH1)) ); //检查传递进来的通道是否正确

    /******************* 开启时钟 和 复用IO口*******************/
    //注，这里代码虽然长，但真正执行的就几条语句
    switch(ftmn)
    {
    case FTM0:
        SIM_SCGC6 |= SIM_SCGC6_FTM0_MASK;                           //使能FTM0时钟
        switch(ch)
        {
        case CH0:
            if(FTM0_CH0 == PTC1)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
                PORT_PCR_REG(PORTC_BASE_PTR, 1) = PORT_PCR_MUX(4);  // PTC1
            }
            else if(FTM0_CH0 == PTA3)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 3) = PORT_PCR_MUX(3);  // PTA3
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH1:
            if(FTM0_CH1 == PTC2)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
                PORT_PCR_REG(PORTC_BASE_PTR, 2) = PORT_PCR_MUX(4);  // PTC2
            }
            else if(FTM0_CH1 == PTA4)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 4) = PORT_PCR_MUX(3);  // PTA4
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH2:
            if(FTM0_CH2 == PTC3)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
                PORT_PCR_REG(PORTC_BASE_PTR, 3) = PORT_PCR_MUX(4);  // PTC3
            }
            else if(FTM0_CH2 == PTA5)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 5) = PORT_PCR_MUX(3);  // PTA5
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH3:
            if(FTM0_CH3 == PTC4)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK;
                PORT_PCR_REG(PORTC_BASE_PTR, 4) = PORT_PCR_MUX(4);  // PTC4
            }
            else if(FTM0_CH3 == PTA6)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 6) = PORT_PCR_MUX(3);  // PTA6
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH4:
            if(FTM0_CH4 == PTD4)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTD_MASK;
                PORT_PCR_REG(PORTD_BASE_PTR, 4) = PORT_PCR_MUX(4);  // PTD4
            }
            else if(FTM0_CH4 == PTA7)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 7) = PORT_PCR_MUX(3);  // PTA7
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH5:
           /* if(FTM0_CH5 == PTD5)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTD_MASK;
                PORT_PCR_REG(PORTD_BASE_PTR, 5) = PORT_PCR_MUX(4);  // PTD5
            }
            else if(FTM0_CH5 == PTA0)
            {*/
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 0) = PORT_PCR_MUX(3);  // PTA0
           /* }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }*/
            break;

        case CH6:
          /*  if(FTM0_CH6 == PTD6)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTD_MASK;
                PORT_PCR_REG(PORTD_BASE_PTR, 6) = PORT_PCR_MUX(4);  // PTD6
            }
            else if(FTM0_CH6 == PTA1)
            {*/
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 1) = PORT_PCR_MUX(3);  // PTA1
            /*}
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }*/
            break;

        case CH7:
            if(FTM0_CH7 == PTD7)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTD_MASK;
                PORT_PCR_REG(PORTD_BASE_PTR, 7) = PORT_PCR_MUX(4);  // PTD7
            }
            else if(FTM0_CH7 == PTA2)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 2) = PORT_PCR_MUX(3);  // PTA2
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;
        default:
            return;
        }
        break;

    case FTM1:
        SIM_SCGC6 |= SIM_SCGC6_FTM1_MASK;                           //使能FTM1时钟
        switch(ch)
        {
        case CH0:
            if(FTM1_CH0 == PTA8)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 8) = PORT_PCR_MUX(3);  // PTA8
            }
            else if(FTM1_CH0 == PTA12)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 12) = PORT_PCR_MUX(3);  // PTA12
            }
            else if(FTM1_CH0 == PTB0)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
                PORT_PCR_REG(PORTB_BASE_PTR, 0) = PORT_PCR_MUX(3);  // PTB0
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;


        case CH1:
            if(FTM1_CH1 == PTA9)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 9) = PORT_PCR_MUX(3);  // PTA9
            }
            else if(FTM1_CH1 == PTA13)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 13) = PORT_PCR_MUX(3);  // PTA13
            }
            else if(FTM1_CH1 == PTB1)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
                PORT_PCR_REG(PORTB_BASE_PTR, 1) = PORT_PCR_MUX(3);  // PTB1
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        default:
            return;
        }
        break;
    case FTM2:
        SIM_SCGC3 |= SIM_SCGC3_FTM2_MASK;                           //使能FTM2时钟
        switch(ch)
        {
        case CH0:
            if(FTM2_CH0 == PTA10)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 10) = PORT_PCR_MUX(3);  // PTA10
            }
            else if(FTM2_CH0 == PTB18)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 18) = PORT_PCR_MUX(3);  // PTB18
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        case CH1:
            if(FTM2_CH1 == PTA11)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 11) = PORT_PCR_MUX(3);  // PTA11
            }
            else if(FTM2_CH1 == PTB19)
            {
                SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
                PORT_PCR_REG(PORTA_BASE_PTR, 19) = PORT_PCR_MUX(3);  // PTB19
            }
            else
            {
                assert_failed(__FILE__, __LINE__);                   //设置管脚有误？
            }
            break;

        default:
            return;
        }
        break;
    default:
        break;
    }


    /******************* 设置为输入捕捉功能 *******************/
    switch(cfg)
    {
    case Rising:    //上升沿触发
        FTM_CnSC_REG(FTMx[ftmn], 0) |=  ( FTM_CnSC_ELSA_MASK  | FTM_CnSC_CHIE_MASK );                   //置1
        FTM_CnSC_REG(FTMx[ftmn], 0) &= ~( FTM_CnSC_ELSB_MASK  | FTM_CnSC_MSB_MASK | FTM_CnSC_MSA_MASK); //清0
        break;

    case Falling:   //下降沿触发
        FTM_CnSC_REG(FTMx[ftmn], 0) |= (FTM_CnSC_ELSB_MASK  | FTM_CnSC_CHIE_MASK );                    //置1
        FTM_CnSC_REG(FTMx[ftmn], 0) &= ~( FTM_CnSC_ELSA_MASK | FTM_CnSC_MSB_MASK | FTM_CnSC_MSA_MASK); //清0
        break;

    case Rising_or_Falling: //上升沿、下降沿都触发
        FTM_CnSC_REG(FTMx[ftmn], 0) |=  ( FTM_CnSC_ELSB_MASK | FTM_CnSC_ELSA_MASK  | FTM_CnSC_CHIE_MASK ); //置1
        FTM_CnSC_REG(FTMx[ftmn], 0) &= ~( FTM_CnSC_MSB_MASK  | FTM_CnSC_MSA_MASK); //清0
        break;
    }

    FTM_SC_REG(FTMx[ftmn]) = FTM_SC_CLKS(0x1);       //System clock

    FTM_MODE_REG(FTMx[ftmn]) |= FTM_MODE_WPDIS_MASK;
    FTM_COMBINE_REG(FTMx[ftmn]) = 0;
    FTM_MODE_REG(FTMx[ftmn]) &= ~FTM_MODE_FTMEN_MASK;
    FTM_CNTIN_REG(FTMx[ftmn]) = 0;

    FTM_STATUS_REG(FTMx[ftmn]) = 0x00;               //清中断标志位

    //开启输入捕捉中断
    enable_irq(78 - 16 + ftmn);
}
/*************************************************************************
*                            蓝宙电子工作室
*
*  函数名称：FTM_QUAD_init
*  功能说明：正交解码模式 初始化函数
*  参数说明：FTMn        模块号（ FTM1、  FTM2）
*            CHn         通道号（CH0~CH1）
*  函数返回：无
*  修改时间：2014-6-25
*  备    注：CH0~CH3可以使用过滤器，未添加这功能
*************************************************************************/
void FTM_QUAD_init(FTMn ftmn,CHn ch)
{
  switch(ftmn)
  {
  case FTM1:
    SIM_SCGC6|=SIM_SCGC6_FTM1_MASK;                             //使能FTM1时钟
    switch(ch)
    {
    case CH0:
      /*if(FTM1_CH0==PTA8)
      {
        SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
        PORT_PCR_REG(PORTA_BASE_PTR, 8) = PORT_PCR_MUX(6);  // PTA8
      }
      else if(FTM1_CH0==PTA12)
      {*/
        SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
        PORT_PCR_REG(PORTA_BASE_PTR, 12) = PORT_PCR_MUX(6);  // PTA12
     /* }
      else if(FTM1_CH0==PTB0)
      {
        SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
        PORT_PCR_REG(PORTB_BASE_PTR, 0) = PORT_PCR_MUX(6);  // PTB0
      }*/
      break;


    case CH1:
     /* if(FTM1_CH1==PTA9)
      {
        SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
        PORT_PCR_REG(PORTA_BASE_PTR, 9) = PORT_PCR_MUX(6);  // PTA9
      }
      else if(FTM1_CH1==PTA13)
      {*/
        SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
        PORT_PCR_REG(PORTA_BASE_PTR, 13) = PORT_PCR_MUX(6);  // PTA13
     /* }
      else if(FTM1_CH1==PTB1)
      {
        SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
        PORT_PCR_REG(PORTB_BASE_PTR, 1) = PORT_PCR_MUX(6);  // PTB1
      }*/
      break;

    default:
      return;
    }
    break;
  case FTM2:
    SIM_SCGC3 |= SIM_SCGC3_FTM2_MASK;                           //使能FTM2时钟
    switch(ch)
    {
    case CH0:
      if(FTM2_CH0==PTA10)
      {
        SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
        PORT_PCR_REG(PORTA_BASE_PTR, 10) = PORT_PCR_MUX(6);  // PTA10
      }
      else if(FTM2_CH0==PTB18)
      {
        SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
        PORT_PCR_REG(PORTA_BASE_PTR, 18) = PORT_PCR_MUX(6);  // PTB18
      }break;

    case CH1:
      if(FTM2_CH1==PTA11)
      {
        SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK;
        PORT_PCR_REG(PORTA_BASE_PTR, 11) = PORT_PCR_MUX(6);  // PTA11
      }
      else if(FTM2_CH1==PTB19)
      {
        SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
        PORT_PCR_REG(PORTA_BASE_PTR, 19) = PORT_PCR_MUX(6);  // PTB19
      }break;

    default:
      return;
    }break;
  default:
    break;
  }
 // FTM_QDCTRL_QUADIR_MASK
  FTM_MODE_REG(FTMx[ftmn]) |= FTM_MODE_WPDIS_MASK|FTM_MODE_FTMEN_MASK;
  FTM_QDCTRL_REG(FTMx[ftmn]) &= ~FTM_QDCTRL_QUADMODE_MASK  ;//AB相同时确定方向和计数值
  FTM_CNTIN_REG(FTMx[ftmn])=0;//FTM0计数器初始值为0
  FTM_MOD_REG(FTMx[ftmn])=65535;//结束值
  FTM_QDCTRL_REG(FTMx[ftmn]) |=FTM_QDCTRL_QUADEN_MASK;//启用FTMn正交解码模式
  FTM_MODE_REG(FTMx[ftmn]) |= FTM_MODE_FTMEN_MASK;   //FTMnEN=1
  FTM_CNT_REG(FTMx[ftmn])=0;

  FTM_SC_REG(FTMx[ftmn]) |= FTM_SC_CLKS(3);  //选择外部时钟

}
/*************************************************************************
*                            蓝宙电子工作室
*
*  函数名称：FTM_SpeedMeasure_init
*  功能说明：正交解码模式 初始化函数
*  参数说明：FTMn        模块号（ FTM1、 FTM2）
*            CHn         通道号（CH0~CH1）
*  函数返回：无
*  修改时间：2014-6-25
*  备    注：CH0~CH3可以使用过滤器，未添加这功能
*************************************************************************/
void FTM_SpeedMeasure_init(void)
{
    PORTA_PCR12= PORT_PCR_MUX(7); // 设置引脚A12引脚为FTM1_PHA功能  
    PORTA_PCR13= PORT_PCR_MUX(7); // 设置引脚A13引脚为FTM1_PHB功能  
    SIM_SCGC6|=SIM_SCGC6_FTM1_MASK;//使能FTM1时钟   
    FTM1_MODE |= FTM_MODE_WPDIS_MASK;//写保护禁止  
    FTM1_QDCTRL|=FTM_QDCTRL_QUADMODE_MASK;//AB相同时确定方向和计数值  
    FTM1_CNTIN=0;//FTM0计数器初始值为0  
    FTM1_MOD=65535;//结束值  
    FTM1_QDCTRL|=FTM_QDCTRL_QUADEN_MASK;//启用FTM1正交解码模式  
    FTM1_MODE |= FTM_MODE_FTMEN_MASK;//FTM1EN=1    
    FTM1_CNT=0;
    
    PORTB_PCR19= PORT_PCR_MUX(6); // 设置引脚B19引脚为FTM2_PHB功能  
    PORTB_PCR18= PORT_PCR_MUX(6); // 设置引脚B18引脚为FTM2_PHA功能  
    SIM_SCGC3|=SIM_SCGC3_FTM2_MASK;//使能FTM2时钟  
    FTM2_MODE |= FTM_MODE_WPDIS_MASK;//写保护禁止  
    FTM2_QDCTRL|=FTM_QDCTRL_QUADMODE_MASK;//AB相同时确定方向和计数值  
    FTM2_CNTIN=0;//FTM0计数器初始值为0  
    FTM2_MOD=65535;//结束值  
    FTM2_QDCTRL|=FTM_QDCTRL_QUADEN_MASK;//启用FTM2正交解码模式  
    FTM2_MODE |= FTM_MODE_FTMEN_MASK;//FTM2EN=1    
    FTM2_CNT=0; 
}


void MotorEN(u8 set)//电机使能
{
	if(set)
	{
		GPIO_SET(PORTC,5,0);//开电机使能     
		GPIO_SET(PORTC,6,0);//开电机使能 
	}
	else 
	{
		GPIO_SET(PORTC,5,1);//关电机使能     
		GPIO_SET(PORTC,6,1);//关电机使能 
                
	}
}



























#if 0
/*************************************************************************
*
*  函数名称：PWM_SET
*  功能说明：设置占空比
*  函数返回：无
*  修改时间：2015-4-10/2016-2-28
*  备    注：
*  作    者：于文海
*************************************************************************/
void PWM_SET(int pwm_left,int pwm_right)
{
  
  
// Motor_Mode==2  //占空比50的方案

  
  #define Pwm_Left_CH  CH2
  #define Pwm_Right_CH CH1
  int Max =  900;//定义区间最大值
  int Min = -900;//定义区间最小值
  int Give=  5  ;//定义补偿数值
  
  int Go  =  1  ;//定义前进动作为1
  int Back=  0  ;//定义后退动作
  
  int Left_GB=5 ;//A电机正反转控制IO
  int Right_GB=6;//B电机正反转控制IO

  pwm_left>=0 ? gpio_set(PORTC,Left_GB,Go) : gpio_set(PORTC,Left_GB ,Back);   //如果pwm_left大于0，正转，否则反转
  pwm_right>=0? gpio_set(PORTC,Right_GB,Go): gpio_set(PORTC,Right_GB,Back);//如果pwm_right大于0，正转，否则反转
  
  pwm_left  = pwm_left  > Max ? Max : (pwm_left  < Min ? Min: (pwm_left + Give));//pwm_left数值限定与补偿
  pwm_right = pwm_right > Max ? Max : (pwm_right < Min ? Min: (pwm_right+ Give));//pwm_right数值限定与补偿
  
  pwm_left =pwm_left >=0?pwm_left : - pwm_left ;//把pwm换算成绝对值状态（大于0）
  pwm_right=pwm_right>=0?pwm_right: - pwm_right;
  FTM_PWM_Duty(FTM0 , Pwm_Left_CH, pwm_left );
  FTM_PWM_Duty(FTM0 , Pwm_Right_CH,pwm_right);
  

// Motor_Mode==1//经典方案
  
  
    #define Pwm_IOA_1  CH0
    #define Pwm_IOA_2  CH1
    #define Pwm_IOB_1  CH2
    #define Pwm_IOB_2  CH3
  
  
    int Max =  900;
    int Min = -900;
    int Give=  5  ;

  
  pwm_left = pwm_left>=Max?Max:pwm_left <=Min?Min:pwm_left+Give;//整定两端数据范围
  pwm_right=pwm_right>=Max?Max:pwm_right<=Min?Min:pwm_right+Give;
  
//检测需要正转还是反转   正转的话   直接把pwm带入正转的一端    不动的一端pwm输出0  如果反转 则相反
  pwm_left>=0?FTM_PWM_Duty (FTM0,Pwm_IOA_1, pwm_left ),FTM_PWM_Duty(FTM0,Pwm_IOA_2,0):FTM_PWM_Duty(FTM0,Pwm_IOA_2,0-pwm_left) ,FTM_PWM_Duty(FTM0,Pwm_IOA_1,0);
  pwm_right>=0?FTM_PWM_Duty(FTM0,Pwm_IOB_1,pwm_right ),FTM_PWM_Duty(FTM0,Pwm_IOB_2,0):FTM_PWM_Duty(FTM0,Pwm_IOB_2,0-pwm_right),FTM_PWM_Duty(FTM0,Pwm_IOB_1,0);
  

  
}
#endif
